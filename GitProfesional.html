<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
    integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous" />
  <title>Curso Profesional de Git</title>
</head>

<body>
  <div class="container">
    <h1>Curso Profesional de Git</h1>
    <div class="container mt-5">
      <h2>¿Qué es un Sistema Control de Versiones?</h2>
      <a href="https://static.platzi.com/media/public/uploads/GIT%20intro_9be7cd0c-f674-4a0f-8bd4-0eac7775da60.pdf"
        target="_blank">Ver presentacion</a>
      <a href="https://docs.google.com/document/d/11L_hhRoqpE-3rLJ6AtwT8Riju-Oc6ys1HRKEItF9Cz4/edit?usp=sharing"
        target="_blank">Libro Fundamentos de Git</a>
      <a href="https://git-scm.com/book/es/v2" target="_blank"> Git Book</a>
      <p>
        Un sistema que registra los cambios realizados sobre un archivo o
        conjunto de archivos a lo largo del tiempo. Este tipo de sistemas nos
        permiten volver en el tiempo y salvar nuestro trabajo.
      </p>
      <h5>Existen 3 tipos</h5>
      <ul>
        <li><strong>Local: </strong> Solo vive en nuestro computador.</li>
        <li>
          <strong>Centralizado: </strong>No depende únicamente de un
          computador en el que se trabaja, sino que depende del súper servidor
          en donde se almacena la información. El servidor provee las copias a
          sus hijos, pero solo guarda los cambios en un solo lugar
        </li>
        <li>
          <strong>Sistema de control distribuidos: </strong>Cada uno de los
          que participan en el proyecto, tienen copia del proyecto que se
          realiza, por eso no dependemos de un solo computador que almacene
          toda la información.
        </li>
      </ul>
      <p>Git es un Sistema de Control de Versiones Distribuido.</p>
    </div>
    <div class="container mt-5">
      <h2>Git</h2>
      <img src="Git-Logo.png" width="180" />
      <p>
        ¿Cómo nace Git? El sistema open source de **Linux necesitaba estar en
        un sistema de control de versiones, entonces Linus Torvalds lo creo
        enfocado en lo siguiente:
      </p>
      <p>
        <strong>Velocidad:</strong> Puedes trabajar fluidamente desde tu
        computador <br /><strong>Diseño sencillo:</strong> El codigo es
        robusto con las herramientas necesarias, como viajar en el tiempo
        <br /><strong>Fuerte apoyo en el desarrollo no lineal:</strong> No es
        necesario seguir un camino predefinido para trabajar. Es decir puedes
        crear otras cosas que no estaban definidas. Al final, en algún punto
        las podrás agregar a tu proyecto.<br /><strong>Completamente distribuido:</strong>
        Cada quien puede tener una copia del proyecto, el repositorio
        principal es casi imposible perderlo <br /><strong>Capaz de manejar grandes proyectos:</strong>
        Linux, Django, Laravel, etc. Usan git
      </p>
      <h5>¿Qué diferencia a Git de los otros VCS?</h5>
      <p>
        Mientras otros VCS solo almacenan los cambios existentes dentro de los
        archivos. Adicionalmente Git crea un enlace a los archivos sin cambios
        en lugar de guardarlos, esto lo hace muy rápido para moverse en el
        tiempo.
      </p>
      <p>
        Casi cualquier trabajo que hagas en Git es local. Es decir que puedes
        trabajar de modo offline sin miedo. Esto porque tienes un repositorio
        en tu computador. Cuando tengas conexión puedes guardar los cambios
        (Commits en Git).
      </p>
      <h5>¿Cómo Git almacena los cambios?</h5>
      <p>
        Git tiene integridad SHA(no puedes perder información durante su
        transmisión o sufrir corrupción de archivos sin que Git lo detecte)
      </p>
      <p>
        Git almacena los cambio en un SHA-1. Esto es un conjunto de 40
        caracteres hexadecimales que harán una referencia a uno de esos
        cambios en nuestro proyecto.
      </p>
    </div>
    <div class="container mt-5">
      <h2>Estados de Git</h2>
      <ol>
        <li>
          <strong>Working Directory: </strong>Archivos nuevos Es donde
          trabajamos de manera local, pero para guardarlo hay que pasarlo al
          Staging Area
        </li>
        <li>
          <strong>Staging Area: </strong>Es el área de preparación, se
          almacenan justo antes de hacer commit
        </li>
        <li>
          <strong>Git repository: </strong> El repositorio donde almacenan los
          cambios del proyecto de forma segura.
        </li>
      </ol>
    </div>
    <div class="container mt-5">
      <h2>¿Qué es GitHub?</h2>
      <p>
        GitHub Es una plataforma en la que se almacenan los cambios de un
        proyecto. Además es una plataforma que funciona como una red social.
        Aquí, las personas que visiten tu sitio puedan darle estrellitas a los
        proyectos que hayas desarrollado. (GitHub es la red social de los
        programadores )
      </p>

      <p>
        <strong>GIT:</strong> Software que nos permite realizar control de
        versiones sobre nuestros proyectos. <br /><br /><strong>GITHUB:</strong>
        Plataforma que nos permite alojar nuestros repositorios en internet,
        además de proveer más utilidades
      </p>
    </div>

    <div class="container mt-5"><!-- Comandos utiles Terminal-->
      <h2>Comandos útiles de la terminal</h2>
      <p>
        <li>
          Movernos dentro de carpetas. ( cd nombreCarpeta) Con ( cd .. )
          podemos salir de la carpeta. (Change Directory)
        </li>
        <li>Crear una carpeta mkdir nombreCarpeta (Make Directory)</li>
        <li>Crear archivos touch nombreArchivo</li>
        <li>Listar los archivos de la carpeta actual ls o dir</li>
        <li>Ver rut actual pwd:</li>
        <li>
          Limpiar la terminal clear. Este nos sirve para hacer scroll e ir al
          principio de la terminal.
        </li>
        <li>Borrar archivos rm nombreArchivo.</li>
        <li>Borrar carpetas rm -rf y el nombreCarpeta.</li>
        <li>Vim nombreArchivo Abrir arhivo en el editor en consola</li>
        <li>
          Comando para Vim Esc :wq (write quit) Guardar y salir cambios que
          hechos al archivo
        </li>
      </p>
    </div>

    <div class="container mt-5"> <!-- Flujos de Trabajo-->
      <h2>Flujos de Trabajo con Git</h2>
      <h4>Configuracion Usuario Global Git</h4>
      <div class="alert alert-dark">
        <samp>
          git config --global user.name "Nombre"// Configurar Nombre<br />
          git config --global user.email "correo@dominio.com" // Configurar
          correo<br />
          git config --global color.ul true //activar colores de git<br />
          git config --global -- list // Ver Configuraciones<br />
          git config --list //Listar datos configurado</samp>
      </div>



      <h4>Inicializando Repositorio "Crear" (git init)</h4>
      <div class="alert alert-dark">
        <samp>
          git init nombreCarpeta // Crea carpeta e inizializa repositorio en
          la misma<br />
          git init //inicializando repositorio en la carpeta actual<br />
          rm -rf .git //borra repositorio local
        </samp>
      </div>

      <h4>Agregando, quitando y viendo el estatus de archivos</h4>
      <p>
        <strong>Untracked files: </strong> Son archivos que están en nuestro
        Working Directory, lo que aparezca en rojo es lo que se ha modificado
        y hay que pasarlo al Staging.
      </p>
      <div class="alert alert-dark">
        <samp>
          git status // Ver estado archivo (Archivo en rojo esta working
          directory, verde staging area) <br />
          git add nombreArchivo // Agg archivo a stagin area<br />
          git add -A // Agrega todos los archivos que hayan sufrido cambios
          (creados, modificados, eliminados).<br />
          git add . // Agrega los archivos creados y modificados, PERO NO los
          eliminados.<br />
          git add -u // Agrega los archivos modificados y eliminados, PERO NO
          los creados.<br />
          git rm --cached nombreArchivo // Devuelve el archivo a working
          direcory<br />
          git reset -q // Devuelve todos los archivos al working<br />

          git rm -f nombreArchivo // Quita del stagin y borra el archivo
          (-F=force)<br />
          git add -n nombreArchivo // Indica si el archivo esta dentro del
          directorio<br />
        </samp>
      </div>
      <p>
        (git add -n)Permite verificar que lo que añadas al commit sea lo
        correcto y que no añadan archivos que no deseas, es más una medida de
        prevención que puedes o no usar
      </p>


      <h4>Confirmando Cambios (git commit - amend)</h4>
      <div class="alert alert-dark">
        <samp>
          git commit -m "mensaje commit" // confirma cambios agregados<br />
          git commit -am "mensaje Commit" // Agrega todos los archivos al
          stagin y a la vez crea el commit, no es recomendable porque usa
          muchos archivos<br />
          git commit --amend (-m "mensaje sin desea renombrar el commit
          anterior")//concatena nuevo archivo o cambios al commit anterior; si
          no agrega mensaje para renombrar, se abre vim y debemos seleccionar
          el nombre del commit. Antes de ejecutar ammend se debe agg el
          archivo al stagin<br />
          git log //lista los commit
        </samp>
      </div>


      <h4>Etiquetando confirmaciones commits (git tag)</h4>
      <p>
        Existen 2 tipos: <br />
        <strong>Ligeras</strong> Se crean con el nombre de la etiqueta Ejem:
        1.0 <br />
        <strong>Anotadas </strong> Son las que llevan la etiqueta y además un
        mensaje lo ayudamos usando -m "mensaje"
      </p>
      <p>#Sha: número del commit de 40 caracteres</p>
      <div class="alert alert-dark">
        <samp>
          git tag numTag // Añade etiqueta Ligera al ultimo commit (numTag=1.0) <br />
          git tag -a numTag -m 'mensajeTag'// Añade etiqueta anotada al ultimo commit<br />
          git tag -l // lista las etiquetas<br>
          git tag // tambien lista las etiquetas<br>
          git tag numTag #Sha // añade etiquetas al commit relacionado con #Sha<br>
          git tag -d numTag // borra etiqueta <br>
          git tag -f -a numTag -m 'Mensaje version' #Sha //renombra etiqueta, despues es necesario borrar la anterior

        </samp>
      </div>
      <h4>Historia del proyecto (git log)</h4>
      <p>Para ver la historia de nuestro proyecto este se invoca con git log, los logs te muestran los códigos
        hexadecimales que crea Sha-1, el autor y la fecha en la que se envió el ese commit.
        Git log se puede personalizar, y de hecho es un comando que se puede personalizar mucho. Para esto podemos usar
        -online que nos ayuda a resumir mucho esos commits.
        Además, podemos ponerle múltiples parámetros, así como consultar solo los logs que nos interesan ver.
        La documentación de git log es súper extensa, y puedes usarla para revisar la historia de nuestro proyecto.</p>
      <div class="alert alert-dark"><samp>
          git log // lista commit de forma estandar<br>
          git log --oneline //lista commit de forma reducida<br>
          git log --oneline --grph // Lista commit reducidos y grafico de los cambios<br>
          git log -2 // Lista los ultimos 2 commit (* el # puede cambiar) <br>
          git log>commit.txt // crear txt con toda la lista de commits
        </samp></div>


      <h5>Logs, para mostrar mejor nuestros commits</h5>
      <P><strong>git lg : </strong>Se usa para obtener información concisa de mis commits muestra la hora el autor el
        gráfico el nombre y el commit id. es muy completo y la version del superlog que utilizo.</P>

      <div class="alert alert-dark"><samp> git config --global alias.lg "log --color --graph
          --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"</samp></div>
    
    <p>resultado: </p>

    <div class="alert alert-dark"><samp> 
       * ||| 6c4b26c - 5 Finale (2 hours ago) <omar crespo="" -="" jackcres=""><br>
       ||_|/<br>
       |/||<br>
       * || 3670cc3 - 4 (4 hours ago) <omar crespo="" -="" jackcres=""><br>
       ||/<br>
       |/|<br>
       * | 789f887 - 3 (4 hours ago) <omar crespo="" -="" jackcres=""><br>
       * |   df26171 - Merge branch 'Responsive' (4 hours ago) <omar crespo="" -="" jackcres=""><br>
       |\ \<br>
       ||/<br>
       | * 30600c8 - a (4 hours ago) <omar crespo="" -="" jackcres=""><br>
       * | 0bc0a42 - 2 (4 hours ago) <omar crespo="" -="" jackcres=""><br>
       |/<br>
       * 857e367 - 1 (4 hours ago) <omar crespo="" -="" jackcres=""><br>
       * c0bd1a9 - Inicio Del Proyecto (4 hours ago) <omar crespo="" -="" jackcres="">     <br> 
    </samp></div>

<p>
  <strong>git Rlog</strong>  RamasLog como le quería poner… Muestra sola la info necesaria para que nos concentremos en el gráfico y podamos analizarlo. Muestra el nombre el commit id y el grafico, poco mas pero ayuda mucho a la hora de analizar el gráfico ya que nos quita lo que no necesitamos para ello
</p>

<div class="alert alert-dark"><samp> git config --global alias.Rlog"log--oneline--graph--all"</samp></div>

<div class="alert alert-dark"><samp> 
   * ||| 6c4b26c 5 Finale<br>
  ||_|/<br>
  |/||<br>
  * || 3670cc3 4<br>
  ||/<br>
  |/|<br>
  * | 789f887 3<br>
  * |   df26171 Merge branch 'Responsive'<br>
  |\ \<br>
  ||/<br>
  | * 30600c8 a<br>
  * | 0bc0a42 2<br>
  |/<br>
  * 857e367 1<br>
  * c0bd1a9 Inicio Del Proyecto
</samp></div>

<h4>Revisando Cambios entre versiones (git diff)</h4>

<p>Si queremos saber cuáles son los cambios que hemos tenido entre un commit y otro, solo debemos hacer una comparación entre un commit y otro usando Sha-1.</p>

<div class="alert alert-dark"><samp>
  git diff #Sha //Muestra  cambios entre estado actual y el commit del Sha<br>
  git diff #Sha #sha1 // Muestra  cambios entre los 2 commit de los Sha asignados (analizar orden de los Sha)<br>
  git diff numTag numTag // Muestra  cambios entre 2 etiquetas
</samp></div>


<h4>Borrar Comit (git reset)</h4>

<p>Alguna vez tuviste un error y quisiste borrar el commit que habías enviado. Para esto podemos hacer a través de git reset.</p>

<h5>git reset --soft</h5>
<p>
  Si quieres usar este comando debes tener mucho cuidado, porque puedes borrar muchos commits.<br>
El comando reset --soft nos permite identificar el commit que queremos resetear.
</p>
<div class="alert alert-dark"><samp> git reset --soft #ShaCommit  //borra commit y los archivos quedan en el working directory (*Borrar desde un commit anterior al que desea borrar)<br>
</samp></div>

<h5>git reset --mixed</h5>
<p>
  Lo podemos usar para hacer cambios a los commits en los que pudimos tener algunos errores.
</p>

<div class="alert alert-dark"><samp> 
  git reset --mixed #ShaCommit // Borra el commit y deja los archivos en el working directory(estado 1)
</samp></div>

<h5>git reset --hard</h5>

<p>vamos a hacer resets que serán definitivos, antes de usar este comando es recomendable craer el archivo txt con los codigo Sha de los commit, es la unica forma de deshacer los camios con este comando</p>

<div class="alert alert-dark"><samp>
  git log>commit.txt // crear txt con toda la lista de commits <br>
  git reset --hard #ShaCommit // Borra commits y archivos del staging area y git repository (Conserva unicamente archivos nuevos (untracked files ) del working directory)<br>
  git reset --hard #ShaCommit // Regresa al #ShaCommit relacionado incluso despues de borrado, para ello es necesario tener copia de los Sha
</samp></div>


<h4>Configurar otro editor de texto diferente a VIM</h4>

<div class="alert alert-dark"><samp>
git config --global core.editor "atom --wait" // Cambio a editor atom<br>
git config --global core.editor "code --wait" // Cambio a editor VS Code<br>
git config --global core.editor "subl --wait"// Cambio a editor Sublime<br>
</samp></div>

</div>

<div class="container mt-5">
   <h2>Multiples entornos de trabajo</h2>


   <h4>Crear Ramas ↑ Multiples Variantes del repo(git branch)</h4>
   <p>Master es la rama principal y la que se crea por defecto en git, sin embargo, podemos crear ramas adicionales para tener una version en pararalelo del proyecto ya sea para arreglar un Bug/fix o para crear un feature.
      Lo ideal es siempre trabajar en una rama diferente a master para que en caso de un fallo no afectar a master que es la principal</p>
   <div class="alert alert-dark"><samp> 
     git branch nombreRama// Crear Ramas <br>
     git branch -l //listar ramas<br>
     git branch -d nombreRama// borrar ramas, No funciona si la rama tiene commits<br>
     git branch -D nobreRama// Forzar borrado ramas sin importar commits<br>
     git branch -m nombreRamaOld nombreRamaNew // renombrar ramas, No es buena practica renombrar master
  </samp></div>

   <h4>Moviendonos entre ramas (git checkout)</h4>

   <div class="alert alert-dark"><samp>
     git checkout nomreRama // Cambiarse de rama<br>
     git checkout #ShaCommit // (No funciono )Ir a commit especifico sin borrar nada y de ahi puede crear una nueva rama<br>
     git checkout numTag // Moverse a una etiqueta<BR>
     git checkout -b nombreRama // Crea rama y se mueve a la misma
  </samp></div>

  <h4>Trabajando entre ramas</h4>
  <p>Si no se realiza el commit de los archivos 
    nuevos o modificados (los que estan en el woking directory,), estos se mueven a cualquier 
    rama a la que cambiemos y unicamnete se guardaran cuando realizemos el commit
  </p>
  <a href="https://www.gitkraken.com/">Gitkraken Interfaz grafica git</a>
  
  <h4>Mezclando ramas y resolviendo conflictos (git merge)</h4>
  <p>Existen 3 tipos: </p>
  <p><strong>Fast-fordward: </strong> cuando la rama es la continuacion directa de la rama donde salio en este caso master, cuando se trabaja en equipo es la primera y la mas facil de mezclar</p>
  <p><strong>Recursiva: </strong>Antes de esta se habia mezclado una del tipo anterior, por ende tenemos cambios en los archivos, es decir master no es igual a cuando se creo la rama que estoy mezclando</p>
  <p><strong>Automezclado con conflictos: </strong> Se abre el editor, debo editar confirmar los cambios y guardar (Entre Head y == es el contenido de master)
  .A continuacion se debe realizar el commit y listo rama fusionada<br>*
Algunas veces se abre el editor para confirmar el nombre del commit de fusion, basta revisar el nombre y  guardar </p>

  <ol>
  <li>Pararse en la rama principal (master)</li>
  <li>Realizar la fusion de las ramas</li>
  <div class="alert alert-dark"><samp> git merge nombreRama // Mezcla rama</samp></div>
</ol>

  <h4>Reescribe la historia de tu proyecto (git rebase)</h4>
<a href="https://www.atlassian.com/es/git/tutorials/rewriting-history/git-rebase">Ver mas sobre rebase</a>
  <p>Rebase es fusionar cambios de una rama secundaria a las principal sin dejar registro de las bifuraciones (rama creadas) , esto con el fin
    de conservar una unica linea de tiempo
    
    
    (Es basicamente mover los commits de una rama secundaria hacia adelante de la rama principal y borrar registros de ramas)
<br><br>
    rebase: reorganización VS   merge: fusionar<br>
  <p> Lo mas recomendable es usar solo merge, Unicamnete usar git rebase de manera local antes de fusionar con el repostorio publico, cuando no deseas compartir las ramas creadas en local
</p>
<p><strong>Nota: </strong> Solo utilizarlo en local, nunca en un remoto porque esto afectaria la historia de todos los repos , un a buena practica seria usar rebase en nuestra rama master  local antes de enviarla al repo remoto , esto con el fin de evitar enviar las bifurcaciones (ramas) del proyecto   
</p>
<img src="Git Rebase.jpg" height="250" alt="">

  <h6>Existen 2 tipos:</h6>
  <ul>
    <li><strong>Manual: </strong>tomará automáticamente las confirmaciones de tu rama de trabajo actual y las aplicará al encabezado de la rama anterior 
      <div class="alert alert-dark"><samp> git rebase nombreRama</samp></div>
    </li>
    
    <li><strong>Interactivo: </strong>Acepta un argumento, nos abre el editor que tengamos definido en la configuración de git para definir la accion a aplicar al comit (elegir,reescribir,editar,fusionar,borrar , etc)
      <div class="alert alert-dark"><samp> git rebase -i nombreRama</samp></div>
    </li>
  </ul>
 <p><strong>Nota:</strong>  El merge siempre se hace después de un rebase a master, ya que si solo usas merge en proyectos grandes no te servirá y solo terminaras rompiéndolo todo. La buena practica es rebase desde tu rama con los nuevos cambios hacia master, te pasas a master, haces merge con la rama que tiene los nuevos cambios y ya fue rebaseada y actualizas master en el repositorio de git.
  <br>pd: siempre recordar hacer fetch antes de cada rebase, saludos</p>


<h4>Guardando cambios temporalmente (git stash)</h4>
<p>Es un estado que tenemos como intermedio antes de guardar el commit, 
  te permite guardar cambios temporalmente y lo podemos usar en caso que tengamos
  que movernos a otra rama y no queremos o aun no estamos seguros de guardar los cambios en un commit
  <br>*Similar a Commit<br><br>
  <strong>Nota: </strong> Los sarchivos deben estar trakeados para que funcion con stash, 
  es decir ya deben haber sido agregados al staging area
 </p>

 <div class="alert alert-dark"><samp> 
    git stash // Guarda estado stash temporalmente<br>
    git stash list // Lista los stash<br>
    git stash drop stash@{numeroStash}  //Borra stash<br>
    git stash apply // aplica cambios, toma el ultimo cambio es decir es stash con valor 0<br>
    git stash apply stash@{numeroStash} //aplica cambios a unstage puntual
 </samp></div>


 <h4>Eligiendo Commits Selectivamente (Cherry pick)</h4>
 <P>Si estás trabajando en una rama, pero de repente notas que hiciste un cambio en 
   la rama que no debías, para esto podemos usar cherry pick. Este comando nos puede 
   salvar la vida, ya que nos permite sacar cambios específicos de una rama y mezclarlos 
   en otra.Para esto es necesario copiar el Sha del commit que desea copiar "mover" y dirigirse 
   a la rama donde se desea mover y aplicar el siguiente comando
  </P>

<div class="alert alert-dark"><samp> 
    git cherry-pick #ShaCommit //Agrega, pega o mueve commit a otra rama
    <br>git checkout -- nombreArchvio.html // Quita ultimos cambios del archivo <br>
  </samp></div>
</div>




<div class="container mt-5">
  <h2>Git Hub</h2>
  <img src="GitHub-Mark.png" width="100" alt="">
  <img src="GitHub-Logo.png" width="100" alt="">

  <h3>Clonando repositorios remotos(git clone/fork) </h3>

  <P>Existen 2 protocolos <strong> HTTP</strong> o <strong>SSH</strong></P>
  <P>Para clonarlo debemos copiar la direccion del repositorio</P>
  <div class="alert alert-dark"><samp>
    git clone direccionRepo //clona repositorio de GitHub a Local 
  </samp></div>
  <h4>Fork (Copia a proyectos ajenos)</h4>
  <P>En este caso debemos ir al repositorio y hacerle fork. De esta forma
    se nos creara una copia del repositorio en nuestra cuenta GitHub</P>

    <h3>Añadiendo llaves SSH a GitHub</h3>
    <P>Se generan desde la consola</P>
    <div class="alert alert-dark"><samp>ssh-keygen -t rsa -b 4096 -C "correo@gmail.com"</samp></div>´
   
    <p>Copiamos la llave SSH con el siguiente comando</p>
    <div class="alert alert-dark"><samp>
      $ cat ~/.ssh/id_rsa.pub<br><br>
      /**Linux**/<br>
      sudo apt-get install xclip #asumiendo que sea ubuntu<br>
      xclip -sel clip < ~/.ssh/id_rsa.pub<br>
      
    </samp></div>
    <p><strong>Opcion 2</strong><br>

      En Windows, al instalar GIT, te descarga GIT GUI.
      Abrir GIT GUI, en el menú HELP, seleccionas la opción show KEYS y allí ves la KEY PUBLICA
      de GIT en tu pc si no la puedes generar con el boton GENERATE KEY.
      <br><br>
      La copias y la compartes en** GITHUB** y eso es todo.</p>
      <p><strong>Nota: </strong> ¿Por que cuando genero la llave ssh me pide un passphrase? es la contraseña de la cuenta en github o ¿para que es?
        Es una contraseña para acceder a esa llave desde tu propia compu, si le das enter - enter queda sin esa contraseña.
        Es una medida se seguridad extra, en caso de que la coloques, necesitaras ingresar la contraseña cada vez que necesites usar la llave. 
        Si haces deploy a un servidor con GIT es mejor que coloques la contraseña y bien segura.</p>

      <h3>Anadiendo Repositorio remoto a Local (git remote)</h3>

      <div class="alert alert-dark"><samp>git remote add origin direccionRepo // vincula repositorio remoto en el local
            <br>***Origin es nombre de repo remoto en local y puede cambiar pero es el estandar<br>
            git remote -v //ver conexion remota<br>
            git remote remove origin //borra repositorio remoto<br>
            git remote set-url origin direccionRepo //modifica la conexión con el repo remoto
           Con esto cambia la URL del remote llamado “origin” ya que podemos tener varios remotes.
      </samp></div>
      <p><strong>Como buenas prácticas, se recomienda lo siguiente:</strong>
            1.El nombre del repositorio creado en Github (u otra plataforma) debe ser el mismo que el nombre de la carpeta del proyecto.<br>
           2.Primero crear el repositorio remoto en Github, luego clonarlo al repositorio local en tu máquina y de ahí empezar a trabajar<br>
      </p>


    <h3>Traer cambios de Repositorios remoto (git pull/fetch)</h3>
    <h4>1. Fetch</h4>
    <p>Decarga cambios del repositorio remoto</p>
    <li>origin: Nombre del repo remoto en Local</li>
    <li>master: Rama traer de repositorio</li>
    <div class="alert alert-dark"><samp>git fetch origin master // traer cambios del repo remoto </samp></div>
    <p>Se crea una nueva rama y acontinuacion se deben mezclar (merge)</p>
    <div class="alert alert-dark"><samp>git merge origin/master //mezclar rama descargada<br>
      git merge origin/master --allow-unrelated-histories //en caso de que el anterior muestre erro
    </samp></div>
    <h4>2.Pull</h4>
    <p>Decarga los cambios y los mezcla a la vez</p>
    <div class="alert alert-dark"><samp>git pull origin master // traer cambios del repo remoto y mezclar  </samp></div>


    <h3>Enviar Cambios al repositorio remoto (git push)</h3>
     <p>Antes de enviar cambios al repositorio es necesario traer los archivos del repositorio remoto 
        y mezclar, esto con el fin de evitar conflictos al hacer push. Tambien debemos enviar nuestras tags y Otras
         ramas
     </p>
     <div class="alert alert-dark"><samp>
        git push origin master //empuja archivos de la rama master a repoRemoto<br>
        git push origin master --tags //empuja tag a repoRemoto<br>
        git push origin nombreRama //empuja rama seleccionada a repoRemoto<br>
        git push origin ramaLocal : ramaRemotaDestino // Enviar desde una rama local cualquiera a una rama cualquiera remota<br>
     </samp></div>

     <h3>Explorando GitHub</h3>
     <ul>
       <li>Podemos calificar los proyectos que hemos creado. </li>
       <li>Podemos ver las estadísticas de nuestro proyecto.</li>
       <li>También las personas que le han hecho fork.     </li>
       <li>Podemos proteger ciertas ramas del proyecto. Recomendacion proteger master (settings>branches)</li>
    <li>Web Hooks.: Agregar Servicios auto deploy a GitHub (AWS etc)</li>
    <li>Issues Son la forma en que manejamos nuestros problemas, bugs en github</li>
    <li>Pull Request Solicitudes de cambios</li>
    
    <br>
    <p>Al crear un “issue” o un “pull request”, github te permite incluir etiquetas en los mismos. 
      Entre las etiquetas que nos pueden interesar a los que estamos comenzando a usar la plataforma 
      se encuentran “help wanted” y “good first issue”. Github anima a los desarrolladores a que marquen
       los “issue” y los “pull request” que son más aptos para los que inician en este mundo con estas 
       etiquetas y adicionalmente se pide a la comunidad que den un apoyo especial para estos issue/pull
        request. ¿Quiéres comenzar a colaborar en un proyecto real en Github pero aún te sientes 
        inseguro con tus conocimientos? Haz una búsqueda de estás etiquetas y encontrarás miles de 
        oportunidades para hacer tu primer aporte.</p>
  </ul>

  <h3>GitHub Projects, el Kanban o tablero de GitHub</h3>
  <p>GitHub tiene unas herramientas increíbles para nuestros proyectos. Una de estas herramientas 
    es el projects de GitHub, que nos da la posibilidad de tener un mayor control del desarrollo 
    de nuestro proyecto.Aquí como en la metodología de SCRUM tenemos la posibilidad de saber qué 
    tenemos pendiente por hacer, cuáles son las features que se encuentran en desarrollo, identificar 
    los bugs que emergen de nuestro proyecto, y los features que debemos revisar.
    </p>
    <p>Crea un Projecto por cada feature grande</p>
    <p>Se Trabaja en columnas y en cada una se crean tareas con <strong>la ventaja que las podemos convertir en un Issue</strong> </p>
    <ul>
      <p>Ejemplo de columnas</p>  
      <li>
        TODO Tareas pendientes.
      </li>
      <li>
        WIP (Work in progress.) En lo que se esta trabajando.
      </li>
      <li>
        Bugs Errores por solucionar.
      </li>
      <li>
        Waiting for review Para que otro/s usuario/s revisen lo echo.
      </li>
      <li>
        DONE Tarea terminada.
      </li>
  </ul>

 <h3>Creando un template para Issues y Pull request</h3>
 <p>Lo ideal es que siempre que creemos un proyecto tengamos un template para enviar pull requests o cuando 
   tengamos issues. En este se escribe todas las preguntas necesarias para detectar y dar solucion al problema.
  </p>
   <p> Se crea usando (Create new file ) y se debe llamar issue_template.md o pull_request_template.md (Mark down)</p>


<p><strong>Nota:</strong> Despues de esto cada vez que generemos un nuevo issue o pull Request se mostrará el nuevo template.</p>
   <h4>
     Issues
   </h4>
    Por lo general son Bugs, mejoras o nuevo features. Puedes etiquetarlos (bug, mejora etc.), asignar el proyecto al que pertenecen 
    y asignarlo a un colaborador

<h4>Pull Request</h4>
<p>Son solicitudes de cambios o aportes a la rama master y que deben ser aprobados</p>
<p>La vida útil de una pull request no debe más de una semana, dependiendo del proyecto y sus periodos de aprobación/despliegue. 
  Una pull request que se dilata en el tiempo demasiado pierde su sentido, al no estar su código actualizado y 
  poder generar conflictos. En caso de no poder hacer el merge por cualquier razón, se deberá de cerrar y 
  cuando vuelva a ser posible hacerlo, actualizar la rama y abrir una nueva pull request.</p>

  <h3> Ignorando archivos (.gitignore)</h3>
  <p>Si tienes archivos que no pueden ser públicos, como archivos de configuración con contraseñas,
  lo ideal es que no los   subas a tu repositorio, estos archivos los puedes poner
  en el archivo .gitignore y asi no seran tenidos en cuenta por git.</p>
  <div class="alert alert-dark"><samp> <a href="http://gitignore.io" target="_blank">gitignore.io</a>  // Guia de archivos a ignorar segun proyecto o lenguaje </samp></div>

  <h3>Colabora Proyectos Externos (Pull Request)</h3>
  <p> Es un proceso mediante el cual un tercero, puede hacer peticiones para incorporar modificaciones al
    proyecto principal sobre el que se está trabajando. Este es el flujo natural, por no decir la manera 
    por defecto en que funciona el trabajo colaborativo, en github, y otras plataformas basadas en git.
  <strong>Por lo general master debe estar protegido y se debe trabajar con otra rama</strong></p>
 
    <ul><li>Asigna reviewers, responsables etc.</li></ul>

    <P><STRONG> 	Consejos </STRONG><br>
      1.- Si eres el dueño del repositorio, debes protejer la rama master, para que siempre alguien externo, pida permiso, para hacer aportes al repo, esto evita que se puedan hacer inyecciones de cambios de manera directa, sin nuestra supervisión.
     <br><br> 2.-Hacer una plantilla dónde, el que va a hacer el aporte detalle aquellas modificaciones que realizo, esto es, para agilizar el flujo colaborativo, y optimizar los procesos de producción de software.</P>

</div>

    </div> <!-- End div main-->

    <div class="alert alert-dark"><samp> ghgh </samp></div>
  </body>
</html>
